identify_product:
  description: |
    Identify which insurance product the user refers to. **Handle typos robustly**.
    If ambiguous, provide a short clarification question.
    Return a JSON object.
  agent: "product_identifier"
  expected_output: |
    { "product": "Travel" | "Maid" | "Car" | "PersonalAccident" | "", "confidence": 0.0-1.0, "question"?: string }


questionnaire_ask_next_slot:
  description: |
    Ask for the next required slot for a recommendation, based on the product and known slots.
    Inputs (via context): Product, Known slots, Next required slot.
    Return a compact JSON object with keys "slot_name" and "question" targeting that specific next slot.
    Keep the question short and user-friendly.
    Preferred phrasing:
    - For plan_preference: "Do you prefer a budget-friendly plan or a comprehensive plan?"
    - For maid_country: "May I know which country is your maid from?"
    - For coverage_above_mom_minimum: "Would you like coverage for medical expenses beyond the MOM minimum requirement?"
    - For add_ons: "Would you be also interested in add-on coverages such as increased Hospital expenses, waiver of excess and medical examination package cover?"
  agent: "questionnaire_agent"
  expected_output: |
    { "slot_name": "<slot>", "question": "<short question>" }

questionnaire_capture_pending_slot:
  description: |
    Capture the user's value for the specific pending slot only. Do not switch slots.
    Inputs (via context): Product, Known slots, Pending slot, User message.
    - If the user's message contains a value for the pending slot, extract and return the core value: {"slot_name":"<pending>","value":"<extracted value>"}.
    - For travel_duration: extract numbers from "200 days", "3 weeks" → return "200", "21" (convert weeks to days).
    - For destination: extract place from "going to Japan" → return "Japan".
    - For medical conditions: extract intent from "I have diabetes" → return "yes".
    - For plan preference: extract intent from "cheapest option" → return "budget".
    - For maid_country: extract country from "from Philippines" → return "Philippines".
    - For coverage_above_mom_minimum: extract intent from "yes, more coverage" → return "yes".
    - For add_ons: extract intent from "yes, interested" → return "required".
    - Otherwise, return {"slot_name":"<pending>","question":"<short clarifying question>"}.
  agent: "questionnaire_agent"
  expected_output: |
    { "slot_name": "<pending>", "value"?: "<extracted core value>", "question"?: "<short clarifying question>" }





identify_tiers:
  description: |
    Identify which tiers to compare for a given product from the user's message and recent session context.
    - Inputs (via context): Product, User message, Recent history window (optional)
    - Output 2+ tiers when available for Travel/Maid; for Car, indicate that tiers do not apply.
    If ambiguous or insufficient, return a short clarification question.
  agent: "tier_identifier"
  expected_output: |
    { "product": "<product>", "tiers": ["<tier>", "<tier>", ...], "question"?: "<short>" }

followup_clarification:
  description: |
    Generate one short, guided clarification question to collect the next missing detail in comparison or summary flow.
    Inputs (via context):
    - await: product|tiers
    - product (may be null)
    - known tiers (optional)
    - recent history (optional)
    - flow_type: comparison|summary (optional, defaults to comparison)
  agent: "followup_clarification_agent"
  expected_output: |
    { "question": "<short question>", "options"?: ["<opt>"] }


synthesize_response:
  description: |
    Use the provided system and user context to synthesize a response.
  agent: "recommendation_responder"
  expected_output: |
    { "response": "<final response>" }

extract_slots:
  description: "Extract and update product-specific slot values from user message using conversation context."
  agent: "slot_extractor"
  expected_output: |
    {
      "slot_name_1": "<extracted/updated value or empty string>",
      "slot_name_2": "<extracted/updated value or empty string>",
      "slot_name_3": "<extracted/updated value or empty string>",
      "user_needs_explanation": "<slot_name if user asks for clarification about a slot, otherwise empty string>",
      "explanation": "<short explanation (under 50 words) ending with a yes/no question if user_needs_explanation is not empty, otherwise empty string>"
    }
    
    Note: Only return slots for the specified product. Use last bot question to disambiguate yes/no answers.
    Can return multiple slots if user provides multiple pieces of information.
    Can update existing slot values if user provides new/different information.
      If user asks for clarification (like "what does that mean?", "I don't know", "explain"), set user_needs_explanation to the relevant slot name and provide a short explanation (under 50 words) ending with a yes/no question.
      Example: {"explanation": "MOM minimum covers basic medical expenses up to $15,000. Additional coverage provides higher limits and more protection. Would you like coverage beyond the MOM minimum? (Yes/No)"}
      Clarification targeting policy (generic): Prefer the last asked slot (from "Last bot question"). If unavailable, target the first missing slot in the provided ordered list.

ask_question:
  description: "Generate a clear, user-friendly question to collect missing slot information for insurance recommendations."
  agent: "question_asker"
  expected_output: |
    { "question": "<clear, concise question for the missing slot>" }


validate_slot:
  description: |
    Your task is to validate and normalize one {product} slot for the given product.

    **CRITICAL RULES:**
    1.  You must validate ONLY the single slot specified in the [Context] block under the "Slot:" key. Do not infer or validate other slots.
    2.  You must use ONLY the validation rules provided in the [Context] block under "Validation rules:".
    3.  Prioritize the provided 'Value' field from the [Context] when it is already in a normalized format (e.g., an integer for days).
    4.  Your response must be a single, complete JSON object that adheres to the Output contract.

    **CLARIFICATION QUESTION FORMAT:**
    - If validation fails because the input is invalid, your generated "question" MUST clearly explain WHY the provided value is incorrect and state the expected format or range.
    - **Example:** "The duration '400 days' is not valid because it is outside the allowed range. Please provide a travel duration between 1 and 365 days."
  agent: "slot_validator"
  expected_output: |
    { "valid": true|false, "slot_name": string, "normalized_value"?: string, "question"?: string, "reason"?: string }

 
route_decision:
  description: |
    Analyze the user's message and recent conversation to determine the primary intent.
    Return a JSON object with a single high-level directive.
  agent: "orchestrator"
  expected_output: |
    { "directive": "greet" | "handle_recommendation" | "handle_information" | "handle_follow_up" | "plan_only_comparison" | "handle_summary" | "handle_capabilities" | "handle_other" }

construct_follow_up_query:
  description: |
    Build a standalone, precise question/query for retrieval from a follow-up message.
    Inputs (via context):
    - Product
    - Latest user message
    - Recent conversation window (up to 5 turns with user/assistant pairs)
    Goals:
    - Resolve pronouns/deixis ("that", "those", "what about limits?") using the window
    - Avoid adding assumptions; prefer quoting exact entities/benefits from the context when possible
    - Output exactly one concise question that can be answered directly by the knowledge base
  agent: "follow_up_agent"
  expected_output: |
    { "query": "<standalone follow-up query>" }



